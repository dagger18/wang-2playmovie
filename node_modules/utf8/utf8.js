/*! https://mths.be/utf8js v2.1.2 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		var compo = '';
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					compo = ((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					compo = value;
					counter--;
				}
			} else {
				compo = value;
			}
			
			output.push(compo);
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	var mapObj = {
'â€ž':'\xE2\x80\x9E',
'â€¦':'\xE2\x80\xA6',
'â€¡':'\xE2\x80\xA1',
'â€°':'\xE2\x80\xB0',
'â€¹':'\xE2\x80\xB9',
'â€˜':'\xE2\x80\x98',
'â€™':'\xE2\x80\x99',
'â€œ':'\xE2\x80\x9C',
'â€¢':'\xE2\x80\xA2',
'â€“':'\xE2\x80\x93',
'â€”':'\xE2\x80\x94',
'â„¢':'\xE2\x84\xA2',
'â€º':'\xE2\x80\xBA',
'â‚¬':'\xE2\x82\xAC',	 	'Ã€':'\xC3\x80',

'Ã‚':'\xC3\x82',
'Æ’':'\xC6\x92',	 		'Ãƒ':'\xC3\x83',
'Ã„':'\xC3\x84',
'Ã…':'\xC3\x85',
'â€':'\xE2\x80\xA0',	 	'Ã†':'\xC3\x86',
'Ã‡':'\xC3\x87',
'Ë†':'\xCB\x86',	 		'Ãˆ':'\xC3\x88',
'Ã‰':'\xC3\x89',
'ÃŠ':'\xC3\x8A',
'Ã‹':'\xC3\x8B',
'Å’':'\xC5\x92',	 		'ÃŒ':'\xC3\x8C',
'Å½':'\xC5\xBD',	 		'ÃŽ':'\xC3\x8E',
'Ã‘':'\xC3\x91',
'Ã’':'\xC3\x92',
'Ã“':'\xC3\x93',
'â€':'\xE2\x80\x9D',	 	'Ã”':'\xC3\x94',
'Ã•':'\xC3\x95',
'Ã–':'\xC3\x96',
'Ã—':'\xC3\x97',
'Ëœ':'\xCB\x9C',	 		'Ã˜':'\xC3\x98',
'Ã™':'\xC3\x99',
'Å¡':'\xC5\xA1',	 		'Ãš':'\xC3\x9A',
'Ã›':'\xC3\x9B',
'Å“':'\xC5\x93',	 		'Ãœ':'\xC3\x9C',

'Å¾':'\xC5\xBE',	 		'Ãž':'\xC3\x9E',
'Å¸':'\xC5\xB8',	 		'ÃŸ':'\xC3\x9F',
 			
'Â¡':'\xC2\xA1',	 		'Ã¡':'\xC3\xA1',
'Â¢':'\xC2\xA2',	 		'Ã¢':'\xC3\xA2',
'Â£':'\xC2\xA3',	 		'Ã£':'\xC3\xA3',
'Â¤':'\xC2\xA4',	 		'Ã¤':'\xC3\xA4',
'Â¥':'\xC2\xA5',	 		'Ã¥':'\xC3\xA5',
'Â¦':'\xC2\xA6',	 		'Ã¦':'\xC3\xA6',
'Â§':'\xC2\xA7',	 		'Ã§':'\xC3\xA7',
'Â¨':'\xC2\xA8',	 		'Ã¨':'\xC3\xA8',
'Â©':'\xC2\xA9',	 		'Ã©':'\xC3\xA9',
'Âª':'\xC2\xAA',	 		'Ãª':'\xC3\xAA',
'Â«':'\xC2\xAB',	 		'Ã«':'\xC3\xAB',
'Â¬':'\xC2\xAC',	 		'Ã¬':'\xC3\xAC',
'Â­':'\xC2\xAD',	 		'Ã­':'\xC3\xAD',
'Â®':'\xC2\xAE',	 		'Ã®':'\xC3\xAE',
'Â¯':'\xC2\xAF',	 		'Ã¯':'\xC3\xAF',
'Â°':'\xC2\xB0',	 		'Ã°':'\xC3\xB0',
'Â±':'\xC2\xB1',	 		'Ã±':'\xC3\xB1',
'Â²':'\xC2\xB2',	 		'Ã²':'\xC3\xB2',
'Â³':'\xC2\xB3',	 		
'Â´':'\xC2\xB4',	 		'Ã´':'\xC3\xB4',
'Âµ':'\xC2\xB5',	 		'Ãµ':'\xC3\xB5',
'Â¶':'\xC2\xB6',	 		'Ã¶':'\xC3\xB6',
'Â·':'\xC2\xB7',	 		'Ã·':'\xC3\xB7',
'Â¸':'\xC2\xB8',	 		'Ã¸':'\xC3\xB8',
'Â¹':'\xC2\xB9',	 		'Ã¹':'\xC3\xB9',
'Âº':'\xC2\xBA',	 		'Ãº':'\xC3\xBA',
'Â»':'\xC2\xBB',	 		'Ã»':'\xC3\xBB',
'Â¼':'\xC2\xBC',	 		'Ã¼':'\xC3\xBC',
'Â½':'\xC2\xBD',	 		'Ã½':'\xC3\xBD',
'Â¾':'\xC2\xBE',	 		'Ã¾':'\xC3\xBE',
'Â¿':'\xC2\xBF',	 		'Ã¿':'\xC3\xBF',
'Â ':'\xC2\xA5',			'Ã³':'\xC3\xB3',
'Å'	:'\xC5\xA0',
	};
	function replaceAll(str,mapObj){
		var re = new RegExp(Object.keys(mapObj).join("|"),"gi");

		return str.replace(re, function(matched){
			return mapObj[matched];
		});
	}
	function utf8decode(byteString) {
		var fixedByteString = replaceAll(byteString,mapObj);
		
		byteArray = ucs2decode(fixedByteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.1.2',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));
